from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from string import printable

def reverse_string(s):
    reversed_string = ""
    for i in range(len(s)-1, -1, -1):
        reversed_string += s[i]
    return reversed_string

server = connect("130.192.5.212", "6543")

#cipher = AES.new(key=b'0'*24, mode=AES.MODE_ECB)
#print(len(cipher.encrypt(pad(b'0'*15, AES.block_size))))

first_len = 0
padding_len = 0
for i in range(17):  #worse case 16 byte(overstimato)
    server.recv(1024) #menu
    server.sendline(b'enc')
    server.recv(1024) #>
    server.sendline((b'00')*i)
    res = bytes.fromhex(server.recvline().decode().strip())
    # print(res)
    if (i == 0):
        first_len = len(res)
    elif len(res) > first_len:
        padding_len = first_len - 46 - i 
        break
print("Padding length: " + str(padding_len))

flag_reverse = ""
flag = ""

for i in range(46):
    server.recv(1024) #menu
    server.sendline(b'enc')
    server.recv(1024) #>
    server.sendline(('a'*(65-46-padding_len+i)).encode().hex().encode()) #65=data+padding+flag is the pos of the first char to brute
    enc_flag = bytes.fromhex(server.recvline().decode().strip())[64:80]
    for char in printable:
        server.recv(1024)
        server.sendline(b'enc')
        server.recv(1024)
        server.sendline((('a'*(16-padding_len)).encode() + pad(char.encode() + flag.encode(), AES.block_size)).hex().encode())
        enc_bytes = bytes.fromhex(server.recvline().decode().strip())
        if enc_bytes[16:32] == enc_flag:
            flag_reverse += char
            flag = reverse_string(flag_reverse)
            print("Flag: " + flag)